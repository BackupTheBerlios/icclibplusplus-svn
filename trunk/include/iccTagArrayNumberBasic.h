#ifndef _H_iccTagArrayNumberBasic_H_#define _H_iccTagArrayNumberBasic_H_#include "iccTag.h"#include "iccDefines.h"#include "iccBasicNumericTypes.h"#include <vector>ICC_LIB_NAMESPACE_STARTtemplate <typename T> class iccTagArrayNumberBasic:	public iccTag{public:        									iccTagArrayNumberBasic(void)        									:m_numbers()        									{}        									iccTagArrayNumberBasic(const iccTagArrayNumberBasic& inTag)        									{        										*this = inTag;        									}    virtual									~iccTagArrayNumberBasic(void)        									{}	virtual	iccNumberUInt32					GetSpecifiedTypeSignature(void) const											{            									if(T == iccNumberUInt8)            										return iccUInt8ArrayType;            									else            									if(T == iccNumberUInt16)            										return iccUInt16ArrayType;            									else            									if(T == iccNumberUInt32)            										return iccUInt32ArrayType;            									else            									if(T == iccNumberUInt64)            										return iccUInt64ArrayType;            								}			iccTagArrayNumberBasic&			operator=(const iccTagArrayNumberBasic& inTag);protected:	virtual	iccError						LoadSelf(std::istream& inStream,unsigned long inSize);	virtual	iccError						SaveSelf(std::ostream& outStream,unsigned long& outSize) const;	virtual	unsigned long					GetSizeSelf(void) const;	virtual	void							InspectSelf(std::vector<iccTagInspector>& outErrorList) const											{}	virtual	void							AutoCorrectSelf(const std::vector<iccTagInspector>& inErrorList)											{} private:			std::vector<T>					m_numbers;};typedef iccTagArrayNumberBasic<iccNumberUInt8>	iccTagArrayUInt8;typedef iccTagArrayNumberBasic<iccNumberUInt16>	iccTagArrayUInt16;typedef iccTagArrayNumberBasic<iccNumberUInt32>	iccTagArrayUInt32;typedef iccTagArrayNumberBasic<iccNumberUInt64>	iccTagArrayUInt64;ICC_LIB_NAMESPACE_END#endif//_H_iccTagArrayNumberBasic_H_