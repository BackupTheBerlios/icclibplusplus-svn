#include "iccTagColorantOrder.h"#include <iostream>using namespace std;USING_ICC_LIB_NAMESPACE//--------------------------------------------------------------------iccTagColorantOrder& iccTagColorantOrder::operator=(const iccTagColorantOrder& inTag){	if(this != &inTag)	{		*(iccTag*)this = *(iccTag*)&inTag;		m_count = inTag.m_count;		m_colorants = inTag.m_colorants;	}	return *this;}//--------------------------------------------------------------------unsigned long iccTagColorantOrder::GetSizeSelf(void) const{	unsigned long	outSize	= 0;		outSize = sizeof m_count;	if(!m_colorants.empty())		outSize += m_colorants.size() * sizeof m_colorants[0];	return outSize;}//--------------------------------------------------------------------iccError iccTagColorantOrder::LoadSelf(istream& inStream,unsigned long inSize){	long	insize		= inSize;	char	colorant	= 0;		inStream >> m_count;	insize -= sizeof m_count;	m_colorants.clear();	while(0 < insize)	{		inStream >> colorant;		m_colorants.push_back(colorant);		insize -= sizeof colorant;	}	return iccErrorNone;}//--------------------------------------------------------------------iccError iccTagColorantOrder::SaveSelf(ostream& outStream,unsigned long& outSize) const{	unsigned long	i		= 0,					imax	= 0;		outStream << m_count;	outSize += sizeof m_count;	for(i=0,imax=m_colorants.size(); i<imax; i++)	{		outStream << m_colorants[i];		outSize += sizeof m_colorants[i];	}	return iccErrorNone;}//--------------------------------------------------------------------void iccTagColorantOrder::InspectSelf(std::vector<iccTagInspector>& outErrorList) const{	unsigned long	i		= 0,					imax	= 0;	unsigned char	mask	= 0;		if(m_requiredNbChannels == 0)		cerr	<< "Error detected in file " << __FILE__				<< ", line " << __LINE__				<< ": The number of channels corresponding to profile color space hasn't been set."				<< endl;		// Check that number of colorants matches number of channels corresponding to profile color space	if(m_colorants.size() != m_requiredNbChannels)		outErrorList.push_back(	iccTagInspector(									GetSignature(),									GetTypeSignature(),									iccTagInspector::ICC_TAG_ERROR_SEVERITY_MINOR,									true,									iccTagInspector::ICC_TAG_GENERIC_ERROR_BAD_VALUE,									iccTagInspector::ICC_TAG_SPECIFIC_ERROR_BAD_COLORANT_COUNT								) );	else	if(m_count != m_colorants.size())		outErrorList.push_back(	iccTagInspector(									GetSignature(),									GetTypeSignature(),									iccTagInspector::ICC_TAG_ERROR_SEVERITY_MINOR,									true,									iccTagInspector::ICC_TAG_GENERIC_ERROR_BAD_VALUE,									iccTagInspector::ICC_TAG_SPECIFIC_ERROR_COLORANT_COUNT_MISMATCH								) );	// Check that each channel is used only once	for(i=0,imax=m_colorants.size(); i<imax; i++)	{		if((mask < (1 << m_colorants[i])) == 1)		{			outErrorList.push_back(	iccTagInspector(										GetSignature(),										GetTypeSignature(),										iccTagInspector::ICC_TAG_ERROR_SEVERITY_MINOR,										true,										iccTagInspector::ICC_TAG_GENERIC_ERROR_BAD_VALUE,										iccTagInspector::ICC_TAG_SPECIFIC_ERROR_BAD_COLORANT_ORDER									) );			break;		}		mask |= 1 << m_colorants[i];	}}//--------------------------------------------------------------------void iccTagColorantOrder::AutoCorrectSelf(const vector<iccTagInspector>& inErrorList){	vector<iccTagInspector>::const_iterator	itError,											itErrorEnd;	unsigned long							i	= 0;	for(itError=inErrorList.begin(),itErrorEnd=inErrorList.end(); itError!=itErrorEnd; itError++)	{		if(			itError->GetTagSignature() == GetSignature()			&& itError->GetTagTypeSignature() == GetTypeSignature()			&& itError->IsAutoCorrective()		)			switch(itError->GetSpecificError())			{				case iccTagInspector::ICC_TAG_SPECIFIC_ERROR_BAD_COLORANT_COUNT:				case iccTagInspector::ICC_TAG_SPECIFIC_ERROR_BAD_COLORANT_ORDER:					m_colorants.clear();					for(i=0; i<m_requiredNbChannels; i++)						m_colorants.push_back((iccOneByteType)i);					// no break				case iccTagInspector::ICC_TAG_SPECIFIC_ERROR_COLORANT_COUNT_MISMATCH:					m_count = m_colorants.size();					break;				default:					break;			}	}}